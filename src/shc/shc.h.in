/**
 * \file charm@P@_shc.h
 *
 * Module to work with spherical harmonic coefficients:
 *
 * * defines the ``charm@P@_shc`` structure to store spherical harmonic 
 *   coefficients,
 *
 * * allocates, initializes and frees ``charm@P@_shc``,
 *
 * * reads/writes spherical harmonic coefficients from/to text and binary 
 *   files,
 *
 * * rescales spherical harmonic coefficients,
 *
 * * computes (difference) degree variances and degree amplitudes.
 *
 * @note This documentation is written for double precision version of CHarm.
 *
 * */






#ifndef __CHARM@PC@_SHC_H__
#define __CHARM@PC@_SHC_H__


/* Header files required by this module */
/* ------------------------------------------------------------------------- */
#include <stdio.h>
#include <charm/charm@P@_err.h>
/* ------------------------------------------------------------------------- */






/* ------------------------------------------------------------------------- */
#ifdef __cplusplus
extern "C"
{
#endif
/* ------------------------------------------------------------------------- */






/* ------------------------------------------------------------------------- */
/**
 *
 * Ordering scheme to write spherical harmonic coefficients with
 * ``charm@P@_shc_write_tbl()``.  */
enum
{
    /**
     *
     * Harmonic degree varies fastest. */
    CHARM_SHC_WRITE_TBL_N,


    /**
     *
     * Harmonic order varies fastest. */
    CHARM_SHC_WRITE_TBL_M
};
/* ------------------------------------------------------------------------- */






/* Structure definitions */
/* ------------------------------------------------------------------------- */

/** Structure to store spherical harmonic coefficients and some associated
 * data. */
typedef struct
{
    /**
     * Maximum harmonic degree of the spherical harmonic coefficients.
     * */
    unsigned long nmax;


    /**
     * Scaling parameter \f$\mu\f$ associated with the spherical harmonic 
     * coefficients, for instance, the geocentric gravitational constant.  In 
     * case the coefficients are not associated with any scaling parameter (as 
     * it is, for instance, with planetary topographies), simply set this 
     * variable to ``1.0`` (not to ``0.0``!). */
    @RDT@ mu;


    /**
     * Radius of the reference sphere \f$R\f$, to which the spherical harmonic 
     * coefficients refer (are scaled).  The value must be greater than 
     * zero. To get the unit sphere, as needed, for instance, when working with 
     * planetary topographies, set this variable to ``1.0``. */
    @RDT@ r;


    /** Total number of spherical harmonic coefficients \f$\bar{C}_{nm}\f$. */
    size_t nc;


    /** Total number of spherical harmonic coefficients \f$\bar{S}_{nm}\f$. */
    size_t ns;


    /**
     * Spherical harmonic coefficients \f$\bar{C}_{nm}\f$ stored as a 2D 
     * array. The first dimension is related to harmonic orders and the second 
     * one to harmonic degrees.  Importantly, the number of columns varies for 
     * each row as follows:
     *
     * * Order ``0``: ``c[0]`` has ``nmax + 1`` columns for degrees ``0``,
     *   ``1``, ..., ``nmax`` (respectively),
     *
     * * Order ``1``: ``c[1]`` has ``nmax`` columns for degrees ``1``, ``2``,
     *   ..., ``nmax`` (respectively),
     *
     * * Order ``2``: ``c[2]`` has ``nmax - 1`` columns for degrees ``2``,
     *   ``3``, ..., ``nmax`` (respectively),
     *
     * * ...
     *
     * * Order ``nmax``: ``c[nmax]`` has ``1`` column for degree ``nmax``.
     *
     * @warning ``c`` is *not* a 2D rectangular array.
     *
     * Assuming the ``charm@P@_shc`` structure was initialized up to some 
     * degree ``unsigned long nmax`` as 
     *
     * \verbatim embed:rst:leading-asterisk
     * .. code-block:: c
     *
     *      charm@P@_shc *shcs = charm@P@_shc_calloc(nmax, 1.0, 1.0);
     *
     * \endverbatim
     *
     * harmonic coefficients of degree ``n <= nmax`` and order ``m <= n`` can 
     * be accessed as:
     *
     *
     * \verbatim embed:rst:leading-asterisk
     * .. code-block:: c
     *
     *      shcs->c[m][n - m];
     *
     * \endverbatim
     *
     * The coefficients in ``c`` are stored in a contiguous block of
     * memory. For fast sequential access, the loop over harmonic orders should
     * always be the outer one, in which the degree-dependent loop is nested,
     * such as:
     *
     * \verbatim embed:rst:leading-asterisk
     * .. code-block:: c
     *
     *     for (unsigned long m = 0; m <= nmax; m++)
     *         for (unsigned long n = m; n <= nmax; n++)
     *             shcs->c[m][n - m];
     *
     * \endverbatim
     * */
    @RDT@ **c;


    /**
     * Spherical harmonic coefficients \f$\bar{S}_{nm}\f$.  The same comments 
     * as for ``c`` apply to ``s``, too.
     * */
    @RDT@ **s;


    /** If ``1``, the spherical harmonic coefficients in ``c`` and ``s`` were
     * allocated by CHarm, so ``charm@P@_shc_free()`` deallocates them.  If
     * ``owner`` is ``0``, the coefficients in ``c`` and ``s`` were allocated
     * outside CHarm, so ``charm@P@_shc_free()`` does *not* deallocate them
     * (the user allocated this memory outside CHarm, so the user should free
     * the memory outside CHarm as well).
     *
     *
     * ``owner`` is set to ``1`` for ``charm@P@_shc`` returned by
     * ``charm@P@_shc_malloc()`` and ``charm@P@_shc_calloc()``.
     * ``charm@P@_shc_init()`` returns ``charm@P@_shc`` with ``owner`` set to
     * ``0``.*/
    _Bool owner;
} charm@P@_shc;
/* ------------------------------------------------------------------------- */






/* Function prototypes */
/* ------------------------------------------------------------------------- */

/** Returns a pointer to the ``charm@P@_shc`` structure that is created with
 * maximum harmonic degree ``nmax``, scaling parameter ``mu``, radius of the
 * reference sphere ``r`` and uninitialized spherical harmonic coefficients.
 * The ``owner`` member of ``charm@P@_shc`` is set to ``1``.
 *
 * On success, returned is a pointer to the ``charm@P@_shc`` structure.  On 
 * error, ``NULL`` is returned.
 *
 * @warning The structure returned must be deallocated by calling
 * ``charm@P@_shc_free()``.  The ``free`` function will *not* deallocate the
 * memory and will lead to memory leaks.
 *
 * @note ``r`` must be greater than zero.
 *
 * */
extern charm@P@_shc *charm@P@_shc_malloc(unsigned long nmax,
                                         @RDT@ mu,
                                         @RDT@ r);






/** The same as ``charm@P@_shc_malloc()`` but all spherical harmonic
 * coefficients are initialized to zero.  */
extern charm@P@_shc *charm@P@_shc_calloc(unsigned long nmax,
                                         @RDT@ mu,
                                         @RDT@ r);






/** Returns a pointer to the ``charm@P@_shc`` structure that is created with
 * maximum harmonic degree ``nmax``, scaling parameter ``mu``, radius of the
 * reference sphere ``r`` and spherical harmonic coefficients from the ``c``
 * and ``s`` arrays (shallow copy).  The ``owner`` member of ``charm@P@_shc``
 * is set to ``0``.
 *
 * On success, returned is a pointer to the ``charm@P@_shc`` structure.  On
 * error, ``NULL`` is returned.
 *
 * The ``c`` and ``s`` pointers must have access to ``((nmax + 2) * (nmax + 1))
 * / 2`` array elements.  The ordering of coefficients in ``c`` and ``s`` must
 * follow the pattern:
 *
 * \verbatim embed:rst:leading-asterisk
 *
 *  .. math::
 *
 *      &\bar{C}_{0,0}, \, \bar{C}_{1,0},\bar{C}_{2,0}, \, \cdots,
 *      \bar{C}_{\mathrm{nmax},0}, \bar{C}_{1,1},\, \bar{C}_{2,1}, \, \cdots,\\
 *      &\bar{C}_{\mathrm{nmax},1}, \, \bar{C}_{2,2}, \bar{C}_{3,2},\,
 *      \cdots,\, \bar{C}_{\mathrm{nmax},\mathrm{nmax}},
 *
 * \endverbatim
 *
 * and
 *
 * \verbatim embed:rst:leading-asterisk
 *
 *  .. math::
 *
 *      &\bar{S}_{0,0}, \, \bar{S}_{1,0},\bar{S}_{2,0}, \, \cdots,
 *      \bar{S}_{\mathrm{nmax},0}, \bar{S}_{1,1},\, \bar{S}_{2,1}, \, \cdots,\\
 *      &\bar{S}_{\mathrm{nmax},1}, \, \bar{S}_{2,2}, \bar{S}_{3,2},\,
 *      \cdots,\, \bar{S}_{\mathrm{nmax},\mathrm{nmax}},
 *
 * \endverbatim
 *
 * respectively.  Be careful here and always put the product
 * ``(nmax + 2) * (nmax + 1)`` into brackets to ensure correct rounding when
 * subsequently dividing by ``2`` as shown above.
 *
 * The rationale behind this function is to provide a means to create
 * a ``charm@P@_shc`` structure from custom arrays of spherical harmonic
 * coefficients *without a deep copy of the data*.  The following code snippet
 * illustrates this:
 *
 * \verbatim embed:rst:leading-asterisk
 *
 *   .. code-block:: c
 *
 *          unsigned long nmax = 10;
 *
 *          size_t ncs = ((nmax + 2) * (nmax + 1)) / 2;
 *
 *          double *myc = (double *)malloc(ncs * sizeof(double));
 *          double *mys = (double *)malloc(ncs * sizeof(double));
 *
 *          // Now fill "myc" and "mys" with your coefficients.
 *          // [Here goes your code]
 *
 *          // Next, create the "charm_shc" structure from the "myc" and "mys"
 *          // coefficients:
 *          charm_shc *shcs = charm_shc_init(nmax, 1.0, 1.0, myc, mys);
 *
 *          // Do some cool things here with "shcs", but remember that
 *          // "shcs->c" and "shcs->s" share the memory space with "myc" and
 *          // "mys", respectively.
 *          // [Here goes your code]
 *
 *          // At this point, we did everything we needed to do with "shcs", so
 *          // let's release the memory associated with it.
 *          charm_shc_free(shcs);
 *          // The "shcs" structure is now properly released.  But
 *          // since "shcs" was created by "charm_shc_init", which does not
 *          // perform a deep copy of the coefficients in "myc" and "mys", the
 *          // memory associated with "myc" and "mys" was not freed.  At this
 *          // point, you may therefore still use "myc" and "mys".
 *          // [Here goes your code]
 *
 *          // Once you are done with "myc" and "mys", release the memory as
 *          // usually with:
 *          free(myc);
 *          free(mys);
 *
 * \endverbatim
 *
 * @warning The structure returned must be deallocated by calling
 * ``charm@P@_shc_free()``.  The ``free`` function will *not* deallocate the
 * memory and will lead to memory leaks.
 *
 * @warning The spherical harmonic coefficients in the returned
 * ``charm@P@_shc`` structure share the memory space with the input ``c`` and
 * ``s`` arrays.  The function does not perform a deep copy of the data.
 * Therefore, ``charm@P@_shc_free()`` properly deallocates the ``charm@P@_shc``
 * structure *except* for the spherical harmonic coefficients.  The user
 * allocated ``c`` and ``s`` outside the scope of CHarm, so the user decides
 * when to deallocate.
 *
 * @note ``r`` must be greater than zero.
 *
 * */
extern charm@P@_shc *charm@P@_shc_init(unsigned long nmax,
                                       @RDT@ mu,
                                       @RDT@ r,
                                       @RDT@ *c,
                                       @RDT@ *s);






/** Frees the memory associated with ``shcs``.  No operation is performed if
 * ``shcs`` is ``NULL``.
 *
 * If ``shcs->owner`` is ``1``, the function releases all the memory that is
 * associated with ``shcs``, including the arrays of spherical harmonic
 * coefficients.  If ``shcs->owner`` is ``0``, the coefficients are not
 * released from the memory, because they were not allocated by CHarm.
 *
 * */
extern void charm@P@_shc_free(charm@P@_shc *shcs);






/** Reads a ``charm@P@_shc`` structure to ``shcs`` from a binary file whose
 *  name is the string pointed to by ``pathname``. The structure is loaded up
 *  to the maximum spherical harmonic degree ``nmax``. The file is assumed to
 *  has been created by ``charm@P@_shc_write_bin()`` on the same architecture.
 *  Error reported by the function (if any) is written to ``err``.
 *
 * The input file is a binary representation of the ``charm@P@_shc`` structure 
 * in the following order:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          &\mathrm{nmax2}, \, \mu, \, R, \bar{C}_{0,0}, \, 
 *          \bar{C}_{1,0},\bar{C}_{2,0}, \, \cdots, \bar{C}_{\mathrm{nmax2},0}, 
 *          \bar{C}_{1,1},\, \bar{C}_{2,1}, \, \cdots,\\
 *          &\bar{C}_{\mathrm{nmax2},1}, \, \bar{C}_{2,2}, \bar{C}_{3,2},\, 
 *          \cdots,\, \bar{C}_{\mathrm{nmax2},\mathrm{nmax2}},\, 
 *          \bar{S}_{0,0},\, \bar{S}_{1,0},\, \bar{S}_{2,0},\, \cdots,\\
 *          &\bar{S}_{\mathrm{nmax2},0},\, \bar{S}_{1,1},\, \bar{S}_{2,1},\, 
 *          \cdots, \bar{S}_{\mathrm{nmax2},1},\,\bar{S}_{2,2},\, 
 *          \bar{S}_{3,2},\, \cdots, \bar{S}_{\mathrm{nmax2},\mathrm{nmax2}},
 *
 * \endverbatim
 *
 * where ``nmax2`` is the maximum harmonic degree related to the 
 * ``charm@P@_shc`` structure stored in the file,
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and, finally,
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``.  It 
 * must hold that ``nmax <= nmax2``.  That is, from all coefficients up to 
 * degree ``nmax2`` that are stored in the file, properly loaded can be any 
 * subset up to degree ``nmax <= nmax2``.
 *
 * It must hold that ``shcs->nmax >= nmax``.
 *
 * @note The function modifies ``shcs->c``, ``shcs->s``, ``shcs->mu`` and
 * ``shcs->r`` by the values from the input file, but it does not touch
 * ``shcs->nmax``, ``shcs->nc`` and ``shcs->ns``.  If ``shcs->nmax > nmax``,
 * the coefficients beyond ``nmax`` are set to zero.
 *
 * */
extern void charm@P@_shc_read_bin(const char *pathname,
                                  unsigned long nmax,
                                  charm@P@_shc *shcs,
                                  charm@P@_err *err);






/** Reads a ``charm@P@_shc`` structure to ``shcs`` from a gfc file whose name
 * is the string pointed to by ``pathname``. The coefficients are loaded up to
 * the maximum spherical harmonic degree ``nmax``.  Error reported by the
 * function (if any) is written to ``err``.
 *
 * The structure of the ``gfc`` file is defined by ICGEM at <a
 * href="http://icgem.gfz-potsdam.de/ICGEM-Format-2011.pdf">http://icgem.gfz-potsdam.de/ICGEM-Format-2011.pdf</a>.
 * It must hold that ``nmax <= nmax2``, where ``nmax2`` is taken from the
 * ``max_degree`` keyword of the ``gfc`` file. From all coefficients up to
 * degree ``nmax2`` that are stored in the file, properly loaded can be any
 * subset up to degree ``nmax <= nmax2``. Lines specifying spherical harmonic
 * coefficients can be sorted *arbitrarily*. The non-existing coefficients
 * \f$\bar{S}_{n,0}\f$ of order ``0`` do not need to be present in the file.
 *
 * It must hold that ``shcs->nmax >= nmax``.
 *
 * @note The function modifies ``shcs->c``, ``shcs->s``, ``shcs->mu`` and
 * ``shcs->r`` by the values from the input file, but it does not touch
 * ``shcs->nmax``, ``shcs->nc`` and ``shcs->ns``.  If ``shcs->nmax > nmax``,
 * the coefficients beyond ``nmax`` are set to zero.
 *
 * */
extern void charm@P@_shc_read_gfc(const char *pathname,
                                  unsigned long nmax,
                                  charm@P@_shc *shcs,
                                  charm@P@_err *err);






/** Reads a ``charm@P@_shc`` structure to ``shcs`` from a text file whose name
 * is the string pointed to by ``pathname``.  The structure is loaded up to the
 * maximum spherical harmonic degree ``nmax``. The file is assumed to has been
 * created by ``charm@P@_shc_write_tbl()``.  Error reported by the function (if
 * any) is written to ``err``.
 *
 * The first line of the input file must specify the maximum harmonic degree
 * ``nmax2`` of the coefficients stored in the file, their scaling parameter
 * ``mu`` and the radius of the reference sphere ``r``.  Then, starting at
 * a new line, provided must be a harmonic degree, harmonic order and the
 * respective pair of coefficients per each line of the file.  The entire file
 * structure can be summarized as:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *
 *          \begin{matrix}
 *          \mathrm{nmax2} & \mu & R\\
 *          0 & 0 & \bar{C}_{0,0} & \bar{S}_{0,0}\\
 *          1 & 0 & \bar{C}_{1,0} & \bar{S}_{1,0}\\
 *          1 & 1 & \bar{C}_{1,1} & \bar{S}_{1,1}\\
 *          2 & 0 & \bar{C}_{2,0} & \bar{S}_{2,0}\\
 *          2 & 1 & \bar{C}_{2,1} & \bar{S}_{2,1}\\
 *          2 & 2 & \bar{C}_{2,2} & \bar{S}_{2,2}\\
 *          \vdots & \vdots & \vdots & \vdots \\
 *          \mathrm{nmax2} & \mathrm{nmax2}
 *          & \bar{C}_{\mathrm{nmax2},\mathrm{nmax2}}
 *          & \bar{S}_{\mathrm{nmax2},\mathrm{nmax2}}\\
 *          \end{matrix}
 *
 * \endverbatim
 *
 * where
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``. It must
 * hold that ``nmax <= nmax2``. That is, from all coefficients up to degree
 * ``nmax2`` that are stored in the file, properly loaded can be any subset up
 * to degree ``nmax <= nmax2``. Lines specifying spherical harmonic
 * coefficients (all lines after the first one) can be sorted
 * *arbitrarily*. The non-existing coefficients \f$\bar{S}_{n,0}\f$ of order
 * ``0`` do not need to be present in the file.
 *
 * It must hold that ``shcs->nmax >= nmax``.
 *
 * @note The function modifies ``shcs->c``, ``shcs->s``, ``shcs->mu`` and
 * ``shcs->r`` by the values from the input file, but it does not touch
 * ``shcs->nmax``, ``shcs->nc`` and ``shcs->ns``.  If ``shcs->nmax > nmax``,
 * the coefficients beyond ``nmax`` are set to zero.
 *
 * */
extern void charm@P@_shc_read_tbl(const char *pathname,
                                  unsigned long nmax,
                                  charm@P@_shc *shcs,
                                  charm@P@_err *err);






/** Reads a ``charm@P@_shc`` structure to ``shcs`` from a text file whose name
 * is the string pointed to by ``pathname``. The structure is loaded up to the
 * maximum spherical harmonic degree ``nmax``. The file is assumed to has been
 * created by ``charm@P@_shc_write_mtx()``.  Error reported by the function (if
 * any) is written to ``err``.
 *
 * The first line of the input file must specify the maximum harmonic degree 
 * ``nmax2`` of the coefficients stored in the file, their scaling parameter 
 * ``mu`` and the radius of the reference sphere ``r``.  Then, starting at 
 * a new line, a matrix with a predefined structured specifying the 
 * coefficients must follow.  The entire file structure can be summarized as:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *
 *          \begin{matrix}
 *          \mathrm{nmax2} & \mu & R\\
 *          \bar{C}_{00} & \bar{S}_{11} &  \bar{S}_{21} & \bar{S}_{31} &
 *              \cdots &\bar{S}_{\mathrm{nmax2},1}\\
 *          \bar{C}_{10} & \bar{C}_{11} &  \bar{S}_{22} & \bar{S}_{32} &
 *          \cdots & \bar{S}_{\mathrm{nmax2},2}\\
 *          \bar{C}_{20} & \bar{C}_{21} &  \bar{C}_{22} & \bar{S}_{33} & \cdots 
 *          & \bar{S}_{\mathrm{nmax2},3}\\
 *          \bar{C}_{30} & \bar{C}_{31} &  \bar{C}_{32} & \bar{C}_{33} & \cdots
 *          & \bar{S}_{\mathrm{nmax2},4}\\
 *          \vdots& \vdots& \vdots& \vdots& \ddots & \vdots \\
 *          \bar{C}_{\mathrm{nmax2},0} & \bar{C}_{\mathrm{nmax2},1}
 *          & \bar{C}_{\mathrm{nmax2},2} & \bar{C}_{\mathrm{nmax2},3} & \cdots
 *          & \bar{C}_{\mathrm{nmax2},\mathrm{nmax2}} \end{matrix}
 *
 * \endverbatim
 *
 * where
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``.  It 
 * must hold that ``nmax <= nmax2``.  That is, from all coefficients up to 
 * degree ``nmax2`` that are stored in the file, properly loaded can be any 
 * subset up to degree ``nmax <= nmax2``.
 *
 * It must hold that ``shcs->nmax >= nmax``.
 *
 * Any empty line in the file (that is, containing only the new line character 
 * ``\n``) is ignored.
 *
 * @note The function modifies ``shcs->c``, ``shcs->s``, ``shcs->mu`` and
 * ``shcs->r`` by the values from the input file, but it does not touch
 * ``shcs->nmax``, ``shcs->nc`` and ``shcs->ns``.  If ``shcs->nmax > nmax``,
 * the coefficients beyond ``nmax`` are set to zero.
 *
 * */
extern void charm@P@_shc_read_mtx(const char *pathname,
                                  unsigned long nmax,
                                  charm@P@_shc *shcs,
                                  charm@P@_err *err);






/** Writes ``shcs`` up to degree ``nmax`` to a binary file whose name is the
 * string pointed to by ``pathname``. Error reported by the function (if any)
 * is written to ``err``.
 *
 * The output file is a binary representation of ``shcs`` up to degree ``nmax`` 
 * in the following order:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          &\mathrm{nmax}, \mu, \, R, \, \bar{C}_{0,0}, \, \bar{C}_{1,0}, \, 
 *          \bar{C}_{2,0}, \, \cdots, \bar{C}_{\mathrm{nmax},0}, 
 *          \bar{C}_{1,1},\, \bar{C}_{2,1}, \, \cdots,\\
 *          &\bar{C}_{\mathrm{nmax},1}, \, \bar{C}_{2,2}, \bar{C}_{3,2},\, 
 *          \cdots,\, \bar{C}_{\mathrm{nmax},\mathrm{nmax}},\, \bar{S}_{0,0},\, 
 *          \bar{S}_{1,0},\, \bar{S}_{2,0},\, \cdots,\\
 *          &\bar{S}_{\mathrm{nmax},0},\, \bar{S}_{1,1},\, \bar{S}_{2,1},\, 
 *          \cdots, \bar{S}_{\mathrm{nmax},1},\,\bar{S}_{2,2},\, 
 *          \bar{S}_{3,2},\, \cdots, \bar{S}_{\mathrm{nmax},\mathrm{nmax}},
 *
 * \endverbatim
 *
 * where
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``.  It 
 * must hold that ``shcs`` stores spherical harmonic coefficients up to degree 
 * ``nmax2 >= nmax``.  That is, from all coefficients in ``shcs`` up to degree 
 * ``nmax2``, properly written can be any subset up to degree
 * ``nmax <= nmax2``.
 *
 * The path to the output file in ``pathname`` must already exist.
 *
 * */
extern void charm@P@_shc_write_bin(const charm@P@_shc *shcs,
                                   unsigned long nmax,
                                   const char *pathname,
                                   charm@P@_err *err);






/** Writes ``shcs`` up to degree ``nmax`` to a text file whose name is the
 * string pointed to by ``pathname`` using the ``format`` specifier and the
 * ``ordering`` scheme for ordering spherical harmonic coefficients.  Error
 * reported by the function (if any) is written to ``err``.
 *
 * The ``format`` specifier is used for all *floating point* data of 
 * ``shcs``. No extra characters before or after the format specifier are 
 * expected, not even the space (no internal check).  Examples of valid 
 * ``format`` specifiers in double precision are ``%0.16e``, ``%24.16e`` or 
 * ``%0.16f``.  The ``format`` specifiers may vary with the precision of the 
 * library (single, double or quadruple).
 *
 * If ``ordering == CHARM_SHC_WRITE_TBL_N``, the output file has the following
 * structure:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *
 *          \begin{matrix}
 *          \mathrm{nmax} & \mu & R\\
 *          0 & 0 & \bar{C}_{0,0} & \bar{S}_{0,0}\\
 *          1 & 0 & \bar{C}_{1,0} & \bar{S}_{1,0}\\
 *          \vdots & \vdots & \vdots & \vdots \\
 *          \mathrm{nmax} & 0 & \bar{C}_{\mathrm{nmax},0}
 *          & \bar{S}_{\mathrm{nmax},0}\\
 *          1 & 1 & \bar{C}_{1,1} & \bar{S}_{1,1}\\
 *          \vdots & \vdots & \vdots & \vdots \\
 *          \mathrm{nmax} & 1 & \bar{C}_{\mathrm{nmax},1}
 *          & \bar{S}_{\mathrm{nmax},1}\\
 *          2 & 2 & \bar{C}_{2,2} & \bar{S}_{2,2}\\
 *          \vdots & \vdots & \vdots & \vdots \\
 *          \mathrm{nmax} & \mathrm{nmax}
 *          & \bar{C}_{\mathrm{nmax},\mathrm{nmax}}
 *          & \bar{S}_{\mathrm{nmax},\mathrm{nmax}}\\
 *          \end{matrix}
 *
 * \endverbatim
 *
 * If ``ordering == CHARM_SHC_WRITE_TBL_M``, the output file has the following
 * structure:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *
 *          \begin{matrix}
 *          \mathrm{nmax} & \mu & R\\
 *          0 & 0 & \bar{C}_{0,0} & \bar{S}_{0,0}\\
 *          1 & 0 & \bar{C}_{1,0} & \bar{S}_{1,0}\\
 *          1 & 1 & \bar{C}_{1,1} & \bar{S}_{1,1}\\
 *          2 & 0 & \bar{C}_{2,0} & \bar{S}_{2,0}\\
 *          2 & 1 & \bar{C}_{2,1} & \bar{S}_{2,1}\\
 *          2 & 2 & \bar{C}_{2,2} & \bar{S}_{2,2}\\
 *          \vdots & \vdots & \vdots & \vdots \\
 *          \mathrm{nmax} & \mathrm{nmax}
 *          & \bar{C}_{\mathrm{nmax},\mathrm{nmax}}
 *          & \bar{S}_{\mathrm{nmax},\mathrm{nmax}}\\
 *          \end{matrix}
 *
 * \endverbatim
 *
 * In either case,
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``.  It 
 * must hold that ``shcs`` stores spherical harmonic coefficients up to degree 
 * ``nmax2 >= nmax``.  That is, from all coefficients in ``shcs`` up to degree 
 * ``nmax2``, properly written can be any subset up to degree
 * ``nmax <= nmax2``.
 *
 * @note In the quadruple version of CHarm (``charmq_shc_write_mtx()``), add
 * the ``Q`` letter to the ``format`` specifier.  Examples of valid ``format``
 * specifiers in quadruple precision are ``%0.34Qe``, ``%40.34Qe`` or
 * ``%0.34Qf`` (see the documentation to ``libquadmath``).
 *
 * The path to the output file in ``pathname`` must already exist.
 *
 * */
extern void charm@P@_shc_write_tbl(const charm@P@_shc *shcs,
                                   unsigned long nmax,
                                   const char *format,
                                   int ordering,
                                   const char *pathname,
                                   charm@P@_err *err);






/** Writes ``shcs`` up to degree ``nmax`` to a text file whose name is the
 * string pointed to by ``pathname`` using the ``format`` specifier.  Error
 * reported by the function (if any) is written to ``err``.
 *
 * The ``format`` specifier is used for all *floating point* data of 
 * ``shcs``. No extra characters before or after the format specifier are 
 * expected, not even the space (no internal check).  Examples of valid 
 * ``format`` specifiers in double precision are ``%0.16e``, ``%24.16e`` or 
 * ``%0.16f``.  The ``format`` specifiers may vary with the precision of the 
 * library (single, double or quadruple).
 *
 * The output file has the following structure:
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *
 *          \begin{matrix}
 *          \mathrm{nmax} & \mu & R\\
 *          \bar{C}_{00} & \bar{S}_{11} &  \bar{S}_{21} & \bar{S}_{31} &
 *              \cdots &\bar{S}_{\mathrm{nmax},1}\\
 *          \bar{C}_{10} & \bar{C}_{11} &  \bar{S}_{22} & \bar{S}_{32} &
 *          \cdots & \bar{S}_{\mathrm{nmax},2}\\
 *          \bar{C}_{20} & \bar{C}_{21} &  \bar{C}_{22} & \bar{S}_{33} & \cdots 
 *          & \bar{S}_{\mathrm{nmax},3}\\
 *          \bar{C}_{30} & \bar{C}_{31} &  \bar{C}_{32} & \bar{C}_{33} & \cdots
 *          & \bar{S}_{\mathrm{nmax},4}\\
 *          \vdots&\vdots &\vdots & \vdots& \ddots & \vdots \\
 *          \bar{C}_{\mathrm{nmax},0} & \bar{C}_{\mathrm{nmax},1}
 *          & \bar{C}_{\mathrm{nmax},2} & \bar{C}_{\mathrm{nmax},3} & \cdots
 *          & \bar{C}_{\mathrm{nmax},\mathrm{nmax}} \end{matrix}
 *
 * \endverbatim
 *
 * where
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \mu, R
 *
 * \endverbatim
 *
 * are the scaling parameter of the coefficients and the associated radius of 
 * the reference sphere and
 *
 * \verbatim embed:rst:leading-asterisk
 *      .. math::
 *          \bar{C}_{n,m}, \, \bar{S}_{n,m}
 *
 * \endverbatim
 *
 * are spherical harmonic coefficients of degree ``n`` and order ``m``.  It 
 * must hold that ``shcs`` stores spherical harmonic coefficients up to degree 
 * ``nmax2 >= nmax``.  That is, from all coefficients in ``shcs`` up to degree 
 * ``nmax2``, properly written can be any subset up to degree
 * ``nmax <= nmax2``.
 *
 * @note In the quadruple version of CHarm (``charmq_shc_write_mtx()``), add
 * the ``Q`` letter to the ``format`` specifier.  Examples of valid ``format``
 * specifiers in quadruple precision are ``%0.34Qe``, ``%40.34Qe`` or
 * ``%0.34Qf`` (see the documentation to ``libquadmath``).
 *
 * The path to the output file in ``pathname`` must already exist.
 *
 * */
extern void charm@P@_shc_write_mtx(const charm@P@_shc *shcs,
                                   unsigned long nmax,
                                   const char *format,
                                   const char *pathname,
                                   charm@P@_err *err);






/**
 * Rescales spherical harmonic coefficients in ``shcs`` to a new scaling 
 * parameter ``munew`` and a new radius of the reference sphere ``rnew``:
 *
 * \verbatim embed:rst:leading-asterisk
 *  .. math::
 *
 *      \bar{C}_{nm}^{\mathrm{new}} = \frac{\mu}{\mu_{\mathrm{new}}} \, \left(
 *                     \frac{R}{R_{\mathrm{new}}} \right)^n \,
 *                     \bar{C}_{nm}\,,\\
 *
 *      \bar{S}_{nm}^{\mathrm{new}} = \frac{\mu}{\mu_{\mathrm{new}}} \, \left(
 *                     \frac{R}{R_{\mathrm{new}}} \right)^n \, \bar{S}_{nm}\,.
 *
 * \endverbatim
 *
 * After the conversion, ``shcs->mu`` and ``shcs->r`` are updated to ``munew`` 
 * and ``rnew``, respectively.
 *
 * Error reported by the function (if any) is written to ``err``.
 *
 * */
extern void charm@P@_shc_rescale(charm@P@_shc *shcs,
                                 @RDT@ munew,
                                 @RDT@ rnew,
                                 charm@P@_err *err);






/**
 * Computes degree variances (spectrum) ``dv`` up to degree ``nmax`` of a 
 * signal given by spherical harmonic coefficients in ``shcs``. Each array 
 * index of ``dv``, ``n = 0``, ``1``, ..., ``nmax``, corresponds to the degree 
 * variance of the respective degree ``n``.
 *
 * Error reported by the function (if any) is written to ``err``.
 *
 * The degree variances are given as
 *
 * \verbatim embed:rst:leading-asterisk
 *  .. math::
 *
 *      \mathrm{dv}_n = \sum_{m = 0}^{n}(\bar{C}_{nm}^2 + \bar{S}_{nm}^2) \,.
 *
 * \endverbatim
 *
 * @note The ``shcs->mu`` and ``shcs->r`` parameters are **not** used to
 * evaluate the degree variances, since this appears to be the most common way
 * in practice.
 *
 * */
extern void charm@P@_shc_dv(const charm@P@_shc *shcs,
                            unsigned long nmax,
                            @RDT@ *dv,
                            charm@P@_err *err);






/**
 * Computes degree amplitudes (square root of degree variances) ``da`` up to 
 * degree ``nmax`` of a signal given by spherical harmonic coefficients in 
 * ``shcs``. Each array index of ``da``, ``n = 0``, ``1``, ..., ``nmax``, 
 * corresponds to the degree amplitude of the respective degree ``n``.
 *
 * Error reported by the function (if any) is written to ``err``.
 *
 * The degree amplitudes are given as
 *
 * \verbatim embed:rst:leading-asterisk
 *  .. math::
 *
 *      \mathrm{da}_n = \sqrt{\sum_{m = 0}^{n}(\bar{C}_{nm}^2 
 *      + \bar{S}_{nm}^2)} \,.
 *
 * \endverbatim
 *
 * @note The ``shcs->mu`` and ``shcs->r`` parameters are **not** used to
 * evaluate the degree amplitudes, since this appears to be the most common way
 * in practice.
 *
 * */
extern void charm@P@_shc_da(const charm@P@_shc *shcs,
                            unsigned long nmax,
                            @RDT@ *da,
                            charm@P@_err *err);






/**
 * Computes difference degree variances (difference spectrum) ``ddv`` up to 
 * degree ``nmax`` between a signal given by spherical harmonic coefficients in 
 * ``shcs1`` and ``shcs2``. Each array index of ``ddv``, ``n = 0``, ``1``, ..., 
 * ``nmax``, corresponds to the difference degree variance of the respective 
 * degree ``n``.
 *
 * Error reported by the function (if any) is written to ``err``.
 *
 * The difference degree variances are given as
 *
 * \verbatim embed:rst:leading-asterisk
 *  .. math::
 *
 *      \mathrm{ddv}_n = \sum_{m = 0}^{n}\left(\left(\bar{C}_{nm}^{(1)} - 
 *      \bar{C}_{nm}^{(2)}\right)^2 + \left(\bar{S}_{nm}^{(1)} 
 *      - \bar{S}_{nm}^{(2)}\right)^2\right) \,.
 *
 * \endverbatim
 *
 * @note The ``shcs->mu`` and ``shcs->r`` parameters are **not** used to
 * evaluate the differece degree variances, since this appears to be the most
 * common way in practice.  However, the values of ``mu`` and ``r`` in
 * ``shcs1`` and ``shcs2`` **must** be equal (the function performs a check on
 * this).
 *
 * */
extern void charm@P@_shc_ddv(const charm@P@_shc *shcs1,
                             const charm@P@_shc *shcs2,
                             unsigned long nmax,
                             @RDT@ *ddv,
                             charm@P@_err *err);






/**
 * Computes difference degree amplitudes (square root of difference degree 
 * variances) ``dda`` up to degree ``nmax`` between a signal given by spherical 
 * harmonic coefficients in ``shcs1`` and ``shcs2``. Each array index of 
 * ``dda``, ``n = 0``, ``1``, ..., ``nmax``, corresponds to the difference 
 * degree amplitude of the respective degree ``n``.
 *
 * Error reported by the function (if any) is written to ``err``.
 *
 * The difference degree amplitudes are given as
 *
 * \verbatim embed:rst:leading-asterisk
 *  .. math::
 *
 *      \mathrm{dda}_n = \sqrt{\sum_{m = 0}^{n}\left(\left(\bar{C}_{nm}^{(1)} - 
 *      \bar{C}_{nm}^{(2)}\right)^2 + \left(\bar{S}_{nm}^{(1)} 
 *      - \bar{S}_{nm}^{(2)}\right)^2\right)} \,.
 *
 * \endverbatim
 *
 * @note The ``shcs->mu`` and ``shcs->r`` parameters are **not** used to
 * evaluate the difference degree amplitudes, since this appears to be the most
 * common way in practice.  However, the values of ``mu`` and ``r`` in
 * ``shcs1`` and ``shcs2`` **must** be equal (the function performs a check on
 * this).
 *
 * */
extern void charm@P@_shc_dda(const charm@P@_shc *shcs1,
                             const charm@P@_shc *shcs2,
                             unsigned long nmax,
                             @RDT@ *da,
                             charm@P@_err *err);
/* ------------------------------------------------------------------------- */






/* ------------------------------------------------------------------------- */
#ifdef __cplusplus
}
#endif
/* ------------------------------------------------------------------------- */


#endif
